<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audio Broadcaster - Listen</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      max-width: 500px;
      width: 100%;
    }

    .card {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 30px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
    }

    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
    }

    h1 {
      font-size: 28px;
      margin-bottom: 0;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .subtitle {
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 30px;
    }

    .status-section {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      font-size: 14px;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #666;
      transition: background 0.3s;
    }

    .status-dot.connected {
      background: #00ff88;
      box-shadow: 0 0 10px #00ff88;
    }

    .status-dot.streaming {
      background: #00d2ff;
      box-shadow: 0 0 10px #00d2ff;
      animation: pulse 2s infinite;
    }

    .status-dot.waiting {
      background: #ffaa00;
      box-shadow: 0 0 10px #ffaa00;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .play-button {
      width: 100%;
      padding: 18px 30px;
      font-size: 18px;
      font-weight: 600;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .play-button.start {
      background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
      color: white;
    }

    .play-button.stop {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%);
      color: white;
    }

    .play-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(0, 210, 255, 0.3);
    }

    .play-button:active {
      transform: translateY(0);
    }

    .play-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .visualizer {
      margin: 30px 0;
      height: 60px;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 4px;
    }

    .bar {
      width: 8px;
      background: linear-gradient(to top, #00d2ff, #3a7bd5);
      border-radius: 4px;
      transition: height 0.1s;
      height: 10px;
    }

    .info {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 13px;
      color: rgba(255, 255, 255, 0.5);
    }

    .info a {
      color: #00d2ff;
      text-decoration: none;
    }

    .error-message {
      background: rgba(255, 107, 107, 0.2);
      border: 1px solid rgba(255, 107, 107, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      font-size: 14px;
      display: none;
    }

    .error-message.visible {
      display: block;
    }

    .name-prompt {
      text-align: center;
    }

    .name-prompt h2 {
      font-size: 20px;
      margin-bottom: 20px;
    }

    .name-input {
      width: 100%;
      padding: 15px;
      font-size: 16px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.3);
      color: #fff;
      margin-bottom: 15px;
      text-align: center;
    }

    .name-input:focus {
      outline: none;
      border-color: #00d2ff;
    }

    .name-input::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    .name-button {
      width: 100%;
      padding: 15px 30px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
      color: white;
      transition: all 0.3s;
    }

    .name-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(0, 210, 255, 0.3);
    }

    .name-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .listener-content {
      display: none;
    }

    .listener-content.visible {
      display: block;
    }

    .warning-message {
      background: rgba(255, 170, 0, 0.2);
      border: 1px solid rgba(255, 170, 0, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      font-size: 14px;
      display: none;
    }

    .warning-message.visible {
      display: block;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="header-row">
        <h1>Listen Live</h1>
        <div class="status-section" id="statusSection">
          <div class="status-indicator">
            <span class="status-dot" id="statusDot"></span>
            <span id="statusText">Disconnected</span>
          </div>
        </div>
      </div>
      <p class="subtitle"></p>

      <div class="error-message" id="error"></div>
      <div class="warning-message" id="warning"></div>

      <!-- Name prompt section -->
      <div class="name-prompt" id="namePrompt">
        <h2>Enter your name to join</h2>
        <input type="text" class="name-input" id="nameInput" placeholder="Your name" maxlength="30" autocomplete="off">
        <button class="name-button" id="joinButton" onclick="joinWithName()">Join Broadcast</button>
      </div>

      <!-- Listener content (hidden until name entered) -->
      <div class="listener-content" id="listenerContent">
      <div class="visualizer" id="visualizer"></div>

      <button class="play-button start" id="playButton" onclick="toggleAudio()">
        <span id="playIcon">▶</span>
        <span id="playText">Start Listening</span>
      </button>

      <!-- <div class="info">
      </div> -->
      </div><!-- end listener-content -->
    </div>
  </div>

  <script>
    // State
    let ws = null;
    let peerConnection = null;
    let audioElement = null;
    let audioContext = null;
    let analyser = null;
    let mediaStreamSource = null;
    let isPlaying = false;
    let listenerName = '';
    let reconnectInterval = null;
    let isReconnecting = false;
    let intentionalStop = false;
    const RECONNECT_DELAY = 3000; // 3 seconds

    // DOM elements
    const playButton = document.getElementById('playButton');
    const playIcon = document.getElementById('playIcon');
    const playText = document.getElementById('playText');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const visualizer = document.getElementById('visualizer');
    const errorEl = document.getElementById('error');
    const warningEl = document.getElementById('warning');
    const namePrompt = document.getElementById('namePrompt');
    const nameInput = document.getElementById('nameInput');
    const joinButton = document.getElementById('joinButton');
    const listenerContent = document.getElementById('listenerContent');

    // Create visualizer bars
    for (let i = 0; i < 20; i++) {
      const bar = document.createElement('div');
      bar.className = 'bar';
      visualizer.appendChild(bar);
    }

    const bars = visualizer.querySelectorAll('.bar');

    function showError(message) {
      errorEl.textContent = message;
      errorEl.classList.add('visible');
      warningEl.classList.remove('visible');
    }

    function showWarning(message) {
      warningEl.textContent = message;
      warningEl.classList.add('visible');
      errorEl.classList.remove('visible');
    }

    function hideMessages() {
      errorEl.classList.remove('visible');
      warningEl.classList.remove('visible');
    }

    function startReconnecting() {
      if (reconnectInterval) return; // Already reconnecting

      isReconnecting = true;
      showWarning('No Active Broadcast. Waiting for broadcaster to start...');
      updateStatus('Waiting', 'waiting');

      // Update button to allow canceling reconnect
      playButton.disabled = false;
      playButton.className = 'play-button stop';
      playIcon.textContent = '\u23F9';
      playText.textContent = 'Stop Waiting';

      reconnectInterval = setInterval(async () => {
        try {
          const response = await fetch('/api/status');
          const data = await response.json();

          if (data.broadcasting) {
            // Broadcaster is back, start listening
            stopReconnecting();
            hideMessages();
            // Use startAudio to properly set up audio context and request offer
            startAudio();
          }
        } catch (e) {
          // Server might be down, keep trying
          console.log('Reconnect check failed:', e);
        }
      }, RECONNECT_DELAY);
    }

    function stopReconnecting() {
      if (reconnectInterval) {
        clearInterval(reconnectInterval);
        reconnectInterval = null;
      }
      isReconnecting = false;
    }

    function joinWithName() {
      const name = nameInput.value.trim();
      if (!name) {
        showError('Please enter your name');
        return;
      }
      listenerName = name;
      // Save name to localStorage
      localStorage.setItem('listenerName', name);
      namePrompt.style.display = 'none';
      listenerContent.classList.add('visible');
      // Connect to server and register (but don't start listening yet)
      connectAndRegister();
    }

    // Connect WebSocket and register as a client (without starting audio)
    function connectAndRegister() {
      if (ws && ws.readyState === WebSocket.OPEN) return;

      updateStatus('Connecting...', 'waiting');

      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${window.location.host}`);

      ws.onopen = () => {
        console.log('WebSocket connected, registering...');
        // Register as a client with name
        ws.send(JSON.stringify({ type: 'register-client', name: listenerName }));
      };

      ws.onmessage = async (event) => {
        try {
          const data = JSON.parse(event.data);
          await handleMessage(data);
        } catch (e) {
          console.error('Error parsing message:', e);
        }
      };

      ws.onclose = () => {
        console.log('WebSocket closed');
        if (!intentionalStop) {
          updateStatus('Disconnected');
        }
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        if (!intentionalStop) {
          showError('Connection failed');
          updateStatus('Disconnected');
        }
      };
    }

    async function handleMessage(data) {
      switch (data.type) {
        case 'registered':
          console.log('Registered as client');
          updateStatus('Connected', 'connected');
          hideMessages();
          // Check if broadcaster is available
          fetch('/api/status')
            .then(r => r.json())
            .then(status => {
              if (!status.broadcasting) {
                showWarning('No broadcaster is currently streaming. Click "Start Listening" when ready.');
              }
            })
            .catch(() => {});
          break;

        case 'offer':
          await handleOffer(data.sdp);
          break;

        case 'ice-candidate':
          await handleIceCandidate(data.candidate);
          break;

        case 'no-broadcaster':
          showWarning('No broadcaster is currently streaming. Waiting for broadcaster...');
          updateStatus('Waiting', 'waiting');
          playButton.disabled = false;
          // Start polling for broadcaster
          startReconnecting();
          break;

        case 'broadcast-ended':
          // Update status to paused
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'status-update', status: 'paused' }));
          }
          cleanupAudioOnly();
          startReconnecting();
          break;

        case 'clients':
          // Just ignore client count updates on listener side
          break;
      }
    }

    // Allow Enter key to submit name
    nameInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        joinWithName();
      }
    });

    // Pre-fill saved name from localStorage
    const savedName = localStorage.getItem('listenerName');
    if (savedName) {
      nameInput.value = savedName;
    }

    function updateStatus(status, state = 'disconnected') {
      statusText.textContent = status;
      statusDot.classList.remove('connected', 'streaming', 'waiting');
      if (state === 'connected') statusDot.classList.add('connected');
      if (state === 'streaming') statusDot.classList.add('streaming');
      if (state === 'waiting') statusDot.classList.add('waiting');
    }

    function updateVisualizer() {
      if (!analyser || !isPlaying) {
        bars.forEach(bar => bar.style.height = '10px');
        return;
      }

      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(dataArray);

      const step = Math.floor(dataArray.length / bars.length);

      bars.forEach((bar, i) => {
        const value = dataArray[i * step];
        const height = Math.max(10, (value / 255) * 60);
        bar.style.height = height + 'px';
      });

      requestAnimationFrame(updateVisualizer);
    }

    async function toggleAudio() {
      if (isPlaying || isReconnecting) {
        stopAudio();
        hideMessages();
      } else {
        await startAudio();
      }
    }

    async function startAudio() {
      intentionalStop = false;
      stopReconnecting();
      hideMessages();
      playButton.disabled = true;
      updateStatus('Connecting...', 'waiting');

      // Clean up any existing peer connection
      if (peerConnection) {
        console.log('Cleaning up existing peer connection');
        peerConnection.close();
        peerConnection = null;
      }
      if (connectionTimeout) {
        clearTimeout(connectionTimeout);
        connectionTimeout = null;
      }

      try {
        // Create audio context for visualization
        if (!audioContext || audioContext.state === 'closed') {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
        }

        // Make sure we have a WebSocket connection
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          connectAndRegister();
          // Wait a bit for connection then request offer
          setTimeout(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'request-offer' }));
            }
          }, 500);
        } else {
          // Already connected, request offer
          ws.send(JSON.stringify({ type: 'request-offer' }));
        }

      } catch (error) {
        console.error('Start error:', error);
        showError('Failed to start: ' + error.message);
        stopAudio();
      }
    }

    let connectionTimeout = null;

    async function handleOffer(sdp) {
      console.log('Received WebRTC offer');

      // Set a connection timeout (15 seconds)
      if (connectionTimeout) clearTimeout(connectionTimeout);
      connectionTimeout = setTimeout(() => {
        if (peerConnection && peerConnection.iceConnectionState !== 'connected' && peerConnection.iceConnectionState !== 'completed') {
          console.log('Connection timeout - ICE state:', peerConnection.iceConnectionState);
          showError('Connection timed out. Try again.');
          playButton.disabled = false;
        }
      }, 15000);

      // Create peer connection
      peerConnection = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      });

      // Add transceiver for receive-only audio (helps iOS Safari)
      peerConnection.addTransceiver('audio', { direction: 'recvonly' });

      // Handle incoming audio track
      peerConnection.ontrack = (event) => {
        console.log('Received audio track');
        const stream = event.streams[0];

        // Create audio element for playback
        audioElement = new Audio();
        audioElement.srcObject = stream;
        audioElement.volume = 1;
        // iOS Safari requirements
        audioElement.setAttribute('playsinline', '');
        audioElement.setAttribute('webkit-playsinline', '');

        // Resume AudioContext if suspended (required for iOS Safari)
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }

        audioElement.play().then(() => {
          isPlaying = true;
          hideMessages();
          updateStatus('Streaming', 'streaming');
          playButton.disabled = false;
          playButton.className = 'play-button stop';
          playIcon.textContent = '\u23F9';
          playText.textContent = 'Stop Listening';

          // Connect stream for visualization
          mediaStreamSource = audioContext.createMediaStreamSource(stream);
          mediaStreamSource.connect(analyser);

          updateVisualizer();
        }).catch(e => {
          console.error('Playback error:', e);
          showError('Playback failed. Try clicking the button again.');
          playButton.disabled = false;
        });
      };

      // Handle ICE candidates
      peerConnection.onicecandidate = (event) => {
        if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
          // Filter out mDNS (.local) candidates - they cause resolution errors
          // and won't work across different networks anyway
          if (event.candidate.candidate && event.candidate.candidate.includes('.local')) {
            console.log('Skipping mDNS candidate:', event.candidate.candidate);
            return;
          }
          ws.send(JSON.stringify({
            type: 'ice-candidate',
            candidate: event.candidate
          }));
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        console.log('ICE connection state:', peerConnection.iceConnectionState);
        switch (peerConnection.iceConnectionState) {
          case 'checking':
            updateStatus('Connecting...', 'waiting');
            break;
          case 'connected':
          case 'completed':
            if (connectionTimeout) {
              clearTimeout(connectionTimeout);
              connectionTimeout = null;
            }
            updateStatus('Streaming', 'streaming');
            break;
          case 'disconnected':
            updateStatus('Reconnecting...', 'waiting');
            break;
          case 'failed':
            if (connectionTimeout) {
              clearTimeout(connectionTimeout);
              connectionTimeout = null;
            }
            showError('Connection failed. Try reconnecting.');
            stopAudio();
            break;
        }
      };

      peerConnection.onicegatheringstatechange = () => {
        console.log('ICE gathering state:', peerConnection.iceGatheringState);
      };

      peerConnection.onconnectionstatechange = () => {
        console.log('Connection state:', peerConnection.connectionState);
      };

      // Set remote description (offer from broadcaster)
      await peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));

      // Create and send answer
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);

      ws.send(JSON.stringify({
        type: 'answer',
        sdp: peerConnection.localDescription
      }));

      console.log('Sent WebRTC answer');
    }

    async function handleIceCandidate(candidate) {
      if (peerConnection && candidate) {
        // Filter out mDNS (.local) candidates - they cause resolution errors
        if (candidate.candidate && candidate.candidate.includes('.local')) {
          console.log('Skipping incoming mDNS candidate:', candidate.candidate);
          return;
        }
        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (error) {
          console.error('Error adding ICE candidate:', error);
        }
      }
    }

    // Cleanup audio/WebRTC only (keep WebSocket connected)
    function cleanupAudioOnly() {
      isPlaying = false;

      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }

      if (audioElement) {
        audioElement.pause();
        audioElement.srcObject = null;
        audioElement = null;
      }

      if (mediaStreamSource) {
        mediaStreamSource.disconnect();
        mediaStreamSource = null;
      }

      if (audioContext) {
        audioContext.close();
        audioContext = null;
        analyser = null;
      }

      bars.forEach(bar => bar.style.height = '10px');
    }

    // Full cleanup including WebSocket
    function cleanupConnection() {
      cleanupAudioOnly();

      if (ws) {
        ws.close();
        ws = null;
      }
    }

    function stopAudio() {
      intentionalStop = true;
      stopReconnecting();

      // Send status update before cleaning up audio
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'status-update', status: 'paused' }));
      }

      cleanupAudioOnly();

      updateStatus('Connected', 'connected');
      playButton.disabled = false;
      playButton.className = 'play-button start';
      playIcon.textContent = '▶';
      playText.textContent = 'Start Listening';
    }

    // Fully disconnect (close WebSocket too)
    function disconnect() {
      intentionalStop = true;
      stopReconnecting();
      cleanupConnection();

      updateStatus('Disconnected');
      playButton.disabled = false;
      playButton.className = 'play-button start';
      playIcon.textContent = '▶';
      playText.textContent = 'Start Listening';
    }

    // Fetch initial status to check if broadcaster is active
    fetch('/api/status')
      .then(r => r.json())
      .then(data => {
        if (!data.broadcasting) {
          showWarning('No broadcaster is currently streaming.');
        }
      })
      .catch(() => {});
  </script>
</body>
</html>
